#!/bin/sh
#
# Run an interactive shell inside an ECS container. That is, run `bash` inside the
# docker container where a service is running.
#
# This is useful for accessing production programatically (e.g.: run `django-admin
# shell` and use the ORM directly.  
#
# Usage:
#   awsh [SERVICE_NAME]
#
# Requirements:
#   aws (also set up properly)
#   jq
#   ssh (make sure you can ssh into the jumphost and into the EC2 host first)

set -e
set -o pipefail

PROFILE=idf
JUMPHOST=ssh.ideasenfoto.com
SERVICE_NAME=${1:-ideasenfoto-django}

# Get the ARN of a task for this service:
TASK_ARN=$(aws ecs --profile $PROFILE list-tasks --cluster production --service-name $SERVICE_NAME| jq -r '.taskArns[0]')

# Get ECS instance data:
ECS_INSTANCE=$(aws ecs --profile $PROFILE describe-tasks --cluster production --tasks $TASK_ARN)
# Extract the ARN of the ECS container instance:
HOST_ARN=$(echo $ECS_INSTANCE | jq -r '.tasks[0].containerInstanceArn')
CONTAINER_ID=$(echo $ECS_INSTANCE | jq -r ".tasks[0].containers[0].runtimeId")

# Get the ARN of the ECS instance (it's basically another id for the same host as above):
EC2_INSTANCE=$(aws ecs --profile $PROFILE describe-container-instances --cluster production --container-instances $HOST_ARN | jq -r '.containerInstances[0].ec2InstanceId')
# Get the DNS name of that host:
EC2_NAME=$(aws ec2 --profile $PROFILE describe-instances --instance-ids $EC2_INSTANCE | jq -r ".Reservations[0].Instances[0].PrivateDnsName")

ssh -atJ $JUMPHOST ec2-user@$EC2_NAME docker exec -it $CONTAINER_ID bash
